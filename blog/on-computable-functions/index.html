<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"On Computable Functions",date:"2013-05-17T00:00:00.000Z",description:"What does it mean for a function to be computable? This question captured the imagination of several incredible mathematicians in the early 20th century, and laid the foundation for the field of computer science. In this post I recall a bit of the history surrounding this question.",slug:"on-computable-functions",tags:["computability","theoretical computer science"],authors:[{name:"Marc Khoury"}],comments:true,html:"\u003Cp\u003EWhat does it mean to be computable? A function is computable if for a given input its output can be calculated by a finite mechanical procedure. But can we pin this idea down with rigorous mathematics?\u003C\u002Fp\u003E\n\u003Cp\u003EIn 1928, David Hilbert \u003Cspan class=\"citation\" data-cites=\"hilbert1902\"\u003E(Hilbert 1902)\u003C\u002Fspan\u003E proposed his famous Entscheidungsproblem, which asks if there is a general procedure for showing that a statement is provable from a given set of axioms. To solve this problem mathematicians first needed to define what it meant to be computable. The first attempt was through primitive recursive functions and was a combined effort by many researchers, including Kurt Gödel, Alonzo Church, Stephen Kleene, Wilhelm Ackermann, John Rosser, and Rózsa Péter.\u003C\u002Fp\u003E\n\u003Ch3 id=\"recursive-functions\"\u003ERecursive Functions\u003C\u002Fh3\u003E\n\u003Cp\u003EPrimitive recursive functions are defined as a recursive type, starting with a few functions that we assume are computable, called founders, and operators that construct new functions from the founders, called constructors. The founders are the following three functions:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EThe constant zero function\u003C\u002Fstrong\u003E: a function that always returns zero\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EThe successor function\u003C\u002Fstrong\u003E: \\(S(n) = n+1\\)\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EThe projection function\u003C\u002Fstrong\u003E: \\(\\text{proj}_{n}^m\\) is an \\(m\\)-ary function that returns the \\(n\\)th argument\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EComputability theory wasn’t going to get very far if these functions weren’t computable. Next, we have two operations for constructing new functions from old: composition and primitive recursion.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003EComposition\u003C\u002Fstrong\u003E: Given a primitive recursive \\(m\\)-ary function \\(h\\) and \\(m\\) \\(n\\)-ary functions \\(g_1,\\ldots, g_m\\), the function \\(f(\\textbf{x}) = h(g_1(\\textbf{x}),\\ldots, g_m(\\textbf{x}))\\) is primitive recursive.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003EPrimitive Recursion\u003C\u002Fstrong\u003E: Given primitive recursive functions \\(g,h\\) the function\n\u003Cspan class=\"math display\"\u003E\\[\\begin{aligned}\nf(\\textbf{x},0) &amp;= g(\\textbf{x})\\\\\nf(\\textbf{x}, y+1) &amp;= h(\\textbf{x},y,f(\\textbf{x},y))\n\\end{aligned}\\]\u003C\u002Fspan\u003E\nis primitive recursive.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EThe set of primitive recursive functions is the set of functions constructed from our three initial functions and closed under composition and primitive recursion. Many familiar functions are primitive recursive: addition, multiplication, exponentiation, primes, max, min, and the logarithm function all fit the bill.\u003C\u002Fp\u003E\n\u003Cp\u003ESo are we done? Is every computable function also primitive recursive? Sadly, no: the Ackermann function would be proven in 1928 to be a counterexample.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cspan class=\"math display\"\u003E\\[\nA(m,n) =\n  \\begin{cases}\n   n+1 &amp; \\text{if } m = 0 \\\\\n   A(m-1,1)  &amp; \\text{if } m &gt; 0 \\text{ and } n = 0\\\\\n   A(m-1,A(m,n-1)) &amp; \\text{if } m &gt; 0 \\text{ and } n &gt; 0\n  \\end{cases}\n\\]\u003C\u002Fspan\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EThe Ackermann function is a total (defined for all inputs) function that is clearly computable but not primitive recursive. Indeed, in 1928 Ackermann \u003Cspan class=\"citation\" data-cites=\"ackermann1928\"\u003E(Ackermann 1928)\u003C\u002Fspan\u003E showed that his function bounds every primitive recursive function: it grows too fast to be primitive recursive.\u003C\u002Fp\u003E\n\u003Cp\u003ESomething was clearly wrong, but early computability theorists didn’t want to abandon primitive recursive functions entirely. What came next was a rather surprising idea at the time: perhaps computable functions need not be total! This was the key that unlocked computability theory: focusing on partial functions, those that may not be defined on all possible inputs.\u003C\u002Fp\u003E\n\u003Cp\u003EThe reason for focusing on partial functions is to allow an unbounded search operator. That is, we want to be able to search for the least input value that satisfies a condition and simply be undefined if no such input value exists. This operation is captured by Kleene’s \\(\\mu\\)-operator.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\\(\\mu\\)-\u003Cstrong\u003Erecursion\u003C\u002Fstrong\u003E: \\(f(x) = (\\mu y)(g(x,y) = 0)\\) returns the least \\(y\\) such that \\(g(x,y) = 0\\) and is undefined if no such \\(y\\) exists. The function \\(g(x,y’)\\) must be defined for all \\(y’ &lt; y\\).\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ETaking the closure of the \\(\\mu\\)-operator with all primitive recursive functions gives a class of \\(\\mu\\)-recursive functions. In 1943, Kleene \u003Cspan class=\"citation\" data-cites=\"kleene1943\"\u003E(Kleene 1943)\u003C\u002Fspan\u003E used his \\(\\mu\\)-operator to provide an alternative, but equivalent, definition of general recursive functions. The original definition was given by Gödel in 1934 \u003Cspan class=\"citation\" data-cites=\"godel1934\"\u003E(Gödel 1934)\u003C\u002Fspan\u003E, based on an observation by Jacques Herbrand. It would later be shown that \\(\\mu\\)-recursive functions are the exact same class of functions defined by two competing approaches \u003Cspan class=\"citation\" data-cites=\"kleene1952\"\u003E(Kleene et al. 1952)\u003C\u002Fspan\u003E.\u003C\u002Fp\u003E\n\u003Ch3 id=\"lambda-calculus\"\u003E\\(\\lambda\\)-Calculus\u003C\u002Fh3\u003E\n\u003Cp\u003ESimultaneously, from 1931-1934, Church and Kleene were developing \\(\\lambda\\)-calculus as an approach to computable functions. The syntax of \\(\\lambda\\)-calculus defines certain expressions as valid statements, which are called \\(\\lambda\\)-terms. A \\(\\lambda\\)-term is built up from a collection of variables and two operators: abstraction and application.\u003C\u002Fp\u003E\n\u003Cp\u003ELet’s start with a collection of variables \\(x,y,z,\\ldots\\) and suppose \\(M, N\\) are valid \\(\\lambda\\)-terms. The abstraction operator creates the term \\(\\lambda x. M\\), which is a function taking an argument \\(x\\) and returning \\(M\\) with each occurrence of \\(x\\) replaced with the argument. The application operator creates the term \\(M N\\), which represents the application of a function \\(M\\) on input \\(N\\).\u003C\u002Fp\u003E\n\u003Cp\u003EThe \\(\\lambda\\)-term \\(\\lambda x.M\\) represents a function \\(f(x) = M\\) and - like recursive functions - many familiar functions are \\(\\lambda\\)-definable. The \\(\\alpha\\)-conversion and \\(\\beta\\)-reduction are classic examples of \u003Cem\u003Ereductions\u003C\u002Fem\u003E, which describe how \\(\\lambda\\)-terms are evaluated. An \\(\\alpha\\)-conversion captures the notion that the name of an argument is usually immaterial. For instance \\(\\lambda x.x\\) and \\(\\lambda y.y\\) both represent the identity function and are \\(\\alpha\\)-equivalent. A \\(\\beta\\)-reduction applies a function to its arguments. Take, as an example, the \\(\\lambda\\)-term \\((\\lambda x.x)y\\), which represents the identity function \\((\\lambda x.x)\\) applied to the input \\(y\\). Substituting the argument \\(y\\) for the parameter \\(x\\), the result of the function is \\(y\\). So we say \\((\\lambda x.x)y\\) \\(\\beta\\)-reduces to \\(y\\).\u003C\u002Fp\u003E\n\u003Cp\u003EIn 1934 Church proposed that the term “effectively calculable” be identified with \\(\\lambda\\)-definable. While Church’s formalization of computability would later be shown to be equivalent to Turing’s, Gödel was dissatisfied with Church’s work. In fairness, Gödel also was dissatisfied with his own work! Church would go on to advocate that “effectively calculable” should be identified with general recursive functions (which Gödel still rejected). In 1936 Church \u003Cspan class=\"citation\" data-cites=\"church1936\"\u003E(Church 1936)\u003C\u002Fspan\u003E published his work proving that that the Entscheidungsproblem was undecidable: there is no general procedure for determining if a statement is provable from a given set of axioms.\u003C\u002Fp\u003E\n\u003Ch3 id=\"turing-machines\"\u003ETuring Machines\u003C\u002Fh3\u003E\n\u003Cp\u003EMeanwhile, after hearing about Hilbert’s Entscheidungsproblem, a 22 year old Cambridge student named Alan Turing began working on his own solution to the problem. Turing was unaware of Church’s work at the time, so his approach wasn’t influenced by \\(\\lambda\\)-expressions (this wasn’t the first time Turing failed to perform a literature review). Instead, he envisioned an idealized human agent performing a computation, which he called a “computer”. To avoid confusion with the modern definition of computer, we’ll adopt the terminology of Robin Gandy and Wilfried Sieg and use the term “computor” to refer to an idealized human agent. The computor had infinite available memory called a tape, essentially an infinite strip of paper, that was divided into squares. The computor could read and write to a square, as well as move from one square to another.\u003C\u002Fp\u003E\n\u003Cp\u003ETuring put several conditions on the computation that the computor could perform. The computor could only have finitely many states (of mind) and the tape could only hold symbols from a finite alphabet. Only a finite number of squares could be observed at a time and the computor could only move to a new square that was at most some finite distance away from an observed square. He also required that any operation must depend only on the current state and the observed symbols, and that there was at most one operation that could be performed per action (his machines were deterministic).\u003C\u002Fp\u003E\n\u003Cp\u003EFrom this, Turing would go on to define his automatic machines - which would later come to be known as Turing machines - and show the equivalence of the two formalizations. He’d then show that “effectively calculable” implied computable by his idealized human agent, which in turn implied computable by such a machine. Turing then went on to show that the Entscheidungsproblem was undecidable. Shortly before publishing his work, he learned that Church had already shown that the Entscheidungsproblem was undecidable using \\(\\lambda\\)-calculus. Turing quickly submitted his work in 1936 \u003Cspan class=\"citation\" data-cites=\"turing1936\"\u003E(Turing 1936)\u003C\u002Fspan\u003E - six months after Church - along with a proof demonstrating the equivalence between his machines and \\(\\lambda\\)-calculus.\u003C\u002Fp\u003E\n\u003Cp\u003EAfter reading Turing’s seminal paper, Gödel was finally convinced that the correct notion of computability had been determined. It would later be shown that all three formalizations - Turing machines, \\(\\mu\\)-recursion, and \\(\\lambda\\)-calculus - actually define the same class of functions. That these three approaches all yielded the same class of functions suggested that mathematicians had captured the correct notion of computation, and supported what would come to be known as the Church-Turing Thesis.\u003C\u002Fp\u003E\n\u003Cp\u003EThree years later, in 1939, Turing completed his Ph.D. at Princeton under the supervision of Church. In his thesis he’d state the following \u003Cspan class=\"citation\" data-cites=\"turing1939\"\u003E(Turing 1939)\u003C\u002Fspan\u003E: “We shall use the expression ‘computable function’ to mean a function calculable by a machine, and let ‘effectively calculable’ refer to the intuitive idea without particular identification with any one of these definitions.”\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003EChurch-Turing Thesis\u003C\u002Fstrong\u003E: Every effectively calculable function is a computable function.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EChurch intended for his original thesis to be taken as a definition of what is computable. Likewise, even though he never stated it, Turing had the same intention. In fact, the term “Church’s Thesis” was coined by Kleene many years after Church had published his work. These days, many people take the Church-Turing Thesis as a definition of what is computable; less formally stating that a function is computable if and only if it can be computed by a Turing machine.\u003C\u002Fp\u003E\n\u003Cp\u003EIt’s important to stress that the Church-Turing Thesis is not a definition as many believe. It does not refer to any particular formalization that we’ve discussed and is not a statement that can be formally proven. It is a statement about the nature of computation. Everything that is “effectively calculable”, in the vague and intuitive sense, is a computable function.\u003C\u002Fp\u003E\n\u003Cdiv id=\"refs\" class=\"references hanging-indent\" role=\"doc-bibliography\"\u003E\n\u003Cdiv id=\"ref-ackermann1928\"\u003E\n\u003Cp\u003EAckermann, Wilhelm. 1928. “Zum Hilbertschen Aufbau Der Reellen Zahlen.” \u003Cem\u003EMathematische Annalen\u003C\u002Fem\u003E 99.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-church1936\"\u003E\n\u003Cp\u003EChurch, Alonzo. 1936. “An Unsolvable Problem of Elementary Number Theory.” \u003Cem\u003EAmerican Journal of Mathematics\u003C\u002Fem\u003E 58.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-godel1934\"\u003E\n\u003Cp\u003EGödel, Kurt. 1934. \u003Cem\u003EOn Undecidable Propositions of Formal Mathematics Systems\u003C\u002Fem\u003E. Institute for Advanced Study.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-hilbert1902\"\u003E\n\u003Cp\u003EHilbert, David. 1902. “Mathematical Problems.” \u003Cem\u003EBulletin of the American Mathematical Society\u003C\u002Fem\u003E 8.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-kleene1943\"\u003E\n\u003Cp\u003EKleene, Stephen Cole. 1943. “Recursive Predicates and Quantifiers.” \u003Cem\u003ETransactions of the American Mathematical Society\u003C\u002Fem\u003E 53.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-kleene1952\"\u003E\n\u003Cp\u003EKleene, Stephen Cole, NG De Bruijn, J de Groot, and Adriaan Cornelis Zaanen. 1952. \u003Cem\u003EIntroduction to Metamathematics\u003C\u002Fem\u003E. Vol. 483. North-Holland Publishing Company.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-turing1936\"\u003E\n\u003Cp\u003ETuring, Alan. 1936. “On Computable Numbers, with an Application to the Entscheidungsproblem.” \u003Cem\u003EProceedings of the London Mathematical Society\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003Cdiv id=\"ref-turing1939\"\u003E\n\u003Cp\u003ETuring, Alan Mathison. 1939. “Systems of Logic Based on Ordinals.” \u003Cem\u003EProceedings of the London Mathematical Society\u003C\u002Fem\u003E 45.\u003C\u002Fp\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.0e3ee94d.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.0e3ee94d.js")}document.head.appendChild(s)</script> <link href=client/main.3211539642.css rel=stylesheet><link href=client/[slug].694885b6.css rel=stylesheet><link href=client/client.0e3ee94d.css rel=stylesheet> <title>On Computable Functions</title><script data-svelte=svelte-j1h3j9>window.MathJax = {
	        tex: {inlineMath: [['$$', '$$'], ['\\[', '\\]'], ['\\(', '\\)']]}
        };
        MathJaxDone = new Promise((resolve, reject) => {
	        window.MathJax = {
		        startup: {
			        pageReady() {
				        return MathJax.startup.defaultPageReady().then(resolve);
			        }
		        }
	        }
        }); </script><script data-svelte=svelte-j1h3j9 async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script data-svelte=svelte-j1h3j9>var disqus_config = function () {
            let tokens = window.location.href.split('/');
            this.page.url = window.location.href;
            if(tokens[tokens.length-1].length === 0) {
                this.page.identifier = "/" + tokens[tokens.length-2];
            } else {
                this.page.identifier = "/" + tokens[tokens.length-1];
            }
        };
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://marckhoury-github-io.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })(); </script><noscript data-svelte=svelte-j1h3j9>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript data-svelte=svelte-j1h3j9>comments powered by Disqus.</a></noscript> <link href=/client/main.3211539642.css rel=preload as=style><link href=/client/[slug].694885b6.css rel=preload as=style><link href=/client/client.0e3ee94d.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-4d1jzv><ul class=svelte-4d1jzv><li class="svelte-4d1jzv font-bold"><a href=. class=svelte-4d1jzv>home</a></li> <li class="svelte-4d1jzv font-bold"><a href=publications class=svelte-4d1jzv>publications</a></li> <li class="svelte-4d1jzv font-bold"><a href=hobbies class=svelte-4d1jzv>hobbies</a></li> <li class="svelte-4d1jzv font-bold"><a href=blog class=svelte-4d1jzv aria-current=page rel=prefetch>blog</a></ul> <ul class=svelte-4d1jzv><li class=svelte-4d1jzv><a href=https://twitter.com/marckkhoury class=svelte-4d1jzv><div class="svelte-4d1jzv icon twitter"><svg class=svelte-c8tyih viewBox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></div></a></li> <li class=svelte-4d1jzv><a href=https://github.com/marckhoury class=svelte-4d1jzv><div class="svelte-4d1jzv icon"><svg class=svelte-c8tyih viewBox="0 0 496 512" xmlns=http://www.w3.org/2000/svg><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></div></a></li> <li class=svelte-4d1jzv><a href=https://www.linkedin.com/in/marckhoury/ class=svelte-4d1jzv><div class="svelte-4d1jzv icon linkedin"><svg class=svelte-c8tyih viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></div></a></li> <li class=svelte-4d1jzv><a href=https://www.twitch.tv/thinkswithtwitch class=svelte-4d1jzv><div class="svelte-4d1jzv icon twitch"><svg class=svelte-c8tyih viewBox="0 0 448 512" xmlns=http://www.w3.org/2000/svg><path d="M40.1 32L10 108.9v314.3h107V480h60.2l56.8-56.8h87l117-117V32H40.1zm357.8 254.1L331 353H224l-56.8 56.8V353H76.9V72.1h321v214zM331 149v116.9h-40.1V149H331zm-107 0v116.9h-40.1V149H224z"></path></svg></div></a></ul></nav> <main class=svelte-1uhnsl8> <h1>On Computable Functions</h1> <div class="content svelte-gnxal1"><p>What does it mean to be computable? A function is computable if for a given input its output can be calculated by a finite mechanical procedure. But can we pin this idea down with rigorous mathematics?</p> <p>In 1928, David Hilbert <span class=citation data-cites=hilbert1902>(Hilbert 1902)</span> proposed his famous Entscheidungsproblem, which asks if there is a general procedure for showing that a statement is provable from a given set of axioms. To solve this problem mathematicians first needed to define what it meant to be computable. The first attempt was through primitive recursive functions and was a combined effort by many researchers, including Kurt Gödel, Alonzo Church, Stephen Kleene, Wilhelm Ackermann, John Rosser, and Rózsa Péter.</p> <h3 id=recursive-functions>Recursive Functions</h3> <p>Primitive recursive functions are defined as a recursive type, starting with a few functions that we assume are computable, called founders, and operators that construct new functions from the founders, called constructors. The founders are the following three functions:</p> <ul> <li><strong>The constant zero function</strong>: a function that always returns zero</li> <li><strong>The successor function</strong>: \(S(n) = n+1\)</li> <li><strong>The projection function</strong>: \(\text{proj}_{n}^m\) is an \(m\)-ary function that returns the \(n\)th argument</li> </ul> <p>Computability theory wasn’t going to get very far if these functions weren’t computable. Next, we have two operations for constructing new functions from old: composition and primitive recursion.</p> <ul> <li><strong>Composition</strong>: Given a primitive recursive \(m\)-ary function \(h\) and \(m\) \(n\)-ary functions \(g_1,\ldots, g_m\), the function \(f(\textbf{x}) = h(g_1(\textbf{x}),\ldots, g_m(\textbf{x}))\) is primitive recursive.</li> <li><strong>Primitive Recursion</strong>: Given primitive recursive functions \(g,h\) the function <span class="display math">\[\begin{aligned} f(\textbf{x},0) &= g(\textbf{x})\\ f(\textbf{x}, y+1) &= h(\textbf{x},y,f(\textbf{x},y)) \end{aligned}\]</span> is primitive recursive.</li> </ul> <p>The set of primitive recursive functions is the set of functions constructed from our three initial functions and closed under composition and primitive recursion. Many familiar functions are primitive recursive: addition, multiplication, exponentiation, primes, max, min, and the logarithm function all fit the bill.</p> <p>So are we done? Is every computable function also primitive recursive? Sadly, no: the Ackermann function would be proven in 1928 to be a counterexample.</p> <p><span class="display math">\[ A(m,n) = \begin{cases} n+1 & \text{if } m = 0 \\ A(m-1,1) & \text{if } m > 0 \text{ and } n = 0\\ A(m-1,A(m,n-1)) & \text{if } m > 0 \text{ and } n > 0 \end{cases} \]</span></p> <p>The Ackermann function is a total (defined for all inputs) function that is clearly computable but not primitive recursive. Indeed, in 1928 Ackermann <span class=citation data-cites=ackermann1928>(Ackermann 1928)</span> showed that his function bounds every primitive recursive function: it grows too fast to be primitive recursive.</p> <p>Something was clearly wrong, but early computability theorists didn’t want to abandon primitive recursive functions entirely. What came next was a rather surprising idea at the time: perhaps computable functions need not be total! This was the key that unlocked computability theory: focusing on partial functions, those that may not be defined on all possible inputs.</p> <p>The reason for focusing on partial functions is to allow an unbounded search operator. That is, we want to be able to search for the least input value that satisfies a condition and simply be undefined if no such input value exists. This operation is captured by Kleene’s \(\mu\)-operator.</p> <ul> <li>\(\mu\)-<strong>recursion</strong>: \(f(x) = (\mu y)(g(x,y) = 0)\) returns the least \(y\) such that \(g(x,y) = 0\) and is undefined if no such \(y\) exists. The function \(g(x,y’)\) must be defined for all \(y’ &lt; y\).</li> </ul> <p>Taking the closure of the \(\mu\)-operator with all primitive recursive functions gives a class of \(\mu\)-recursive functions. In 1943, Kleene <span class=citation data-cites=kleene1943>(Kleene 1943)</span> used his \(\mu\)-operator to provide an alternative, but equivalent, definition of general recursive functions. The original definition was given by Gödel in 1934 <span class=citation data-cites=godel1934>(Gödel 1934)</span>, based on an observation by Jacques Herbrand. It would later be shown that \(\mu\)-recursive functions are the exact same class of functions defined by two competing approaches <span class=citation data-cites=kleene1952>(Kleene et al. 1952)</span>.</p> <h3 id=lambda-calculus>\(\lambda\)-Calculus</h3> <p>Simultaneously, from 1931-1934, Church and Kleene were developing \(\lambda\)-calculus as an approach to computable functions. The syntax of \(\lambda\)-calculus defines certain expressions as valid statements, which are called \(\lambda\)-terms. A \(\lambda\)-term is built up from a collection of variables and two operators: abstraction and application.</p> <p>Let’s start with a collection of variables \(x,y,z,\ldots\) and suppose \(M, N\) are valid \(\lambda\)-terms. The abstraction operator creates the term \(\lambda x. M\), which is a function taking an argument \(x\) and returning \(M\) with each occurrence of \(x\) replaced with the argument. The application operator creates the term \(M N\), which represents the application of a function \(M\) on input \(N\).</p> <p>The \(\lambda\)-term \(\lambda x.M\) represents a function \(f(x) = M\) and - like recursive functions - many familiar functions are \(\lambda\)-definable. The \(\alpha\)-conversion and \(\beta\)-reduction are classic examples of <em>reductions</em>, which describe how \(\lambda\)-terms are evaluated. An \(\alpha\)-conversion captures the notion that the name of an argument is usually immaterial. For instance \(\lambda x.x\) and \(\lambda y.y\) both represent the identity function and are \(\alpha\)-equivalent. A \(\beta\)-reduction applies a function to its arguments. Take, as an example, the \(\lambda\)-term \((\lambda x.x)y\), which represents the identity function \((\lambda x.x)\) applied to the input \(y\). Substituting the argument \(y\) for the parameter \(x\), the result of the function is \(y\). So we say \((\lambda x.x)y\) \(\beta\)-reduces to \(y\).</p> <p>In 1934 Church proposed that the term “effectively calculable” be identified with \(\lambda\)-definable. While Church’s formalization of computability would later be shown to be equivalent to Turing’s, Gödel was dissatisfied with Church’s work. In fairness, Gödel also was dissatisfied with his own work! Church would go on to advocate that “effectively calculable” should be identified with general recursive functions (which Gödel still rejected). In 1936 Church <span class=citation data-cites=church1936>(Church 1936)</span> published his work proving that that the Entscheidungsproblem was undecidable: there is no general procedure for determining if a statement is provable from a given set of axioms.</p> <h3 id=turing-machines>Turing Machines</h3> <p>Meanwhile, after hearing about Hilbert’s Entscheidungsproblem, a 22 year old Cambridge student named Alan Turing began working on his own solution to the problem. Turing was unaware of Church’s work at the time, so his approach wasn’t influenced by \(\lambda\)-expressions (this wasn’t the first time Turing failed to perform a literature review). Instead, he envisioned an idealized human agent performing a computation, which he called a “computer”. To avoid confusion with the modern definition of computer, we’ll adopt the terminology of Robin Gandy and Wilfried Sieg and use the term “computor” to refer to an idealized human agent. The computor had infinite available memory called a tape, essentially an infinite strip of paper, that was divided into squares. The computor could read and write to a square, as well as move from one square to another.</p> <p>Turing put several conditions on the computation that the computor could perform. The computor could only have finitely many states (of mind) and the tape could only hold symbols from a finite alphabet. Only a finite number of squares could be observed at a time and the computor could only move to a new square that was at most some finite distance away from an observed square. He also required that any operation must depend only on the current state and the observed symbols, and that there was at most one operation that could be performed per action (his machines were deterministic).</p> <p>From this, Turing would go on to define his automatic machines - which would later come to be known as Turing machines - and show the equivalence of the two formalizations. He’d then show that “effectively calculable” implied computable by his idealized human agent, which in turn implied computable by such a machine. Turing then went on to show that the Entscheidungsproblem was undecidable. Shortly before publishing his work, he learned that Church had already shown that the Entscheidungsproblem was undecidable using \(\lambda\)-calculus. Turing quickly submitted his work in 1936 <span class=citation data-cites=turing1936>(Turing 1936)</span> - six months after Church - along with a proof demonstrating the equivalence between his machines and \(\lambda\)-calculus.</p> <p>After reading Turing’s seminal paper, Gödel was finally convinced that the correct notion of computability had been determined. It would later be shown that all three formalizations - Turing machines, \(\mu\)-recursion, and \(\lambda\)-calculus - actually define the same class of functions. That these three approaches all yielded the same class of functions suggested that mathematicians had captured the correct notion of computation, and supported what would come to be known as the Church-Turing Thesis.</p> <p>Three years later, in 1939, Turing completed his Ph.D. at Princeton under the supervision of Church. In his thesis he’d state the following <span class=citation data-cites=turing1939>(Turing 1939)</span>: “We shall use the expression ‘computable function’ to mean a function calculable by a machine, and let ‘effectively calculable’ refer to the intuitive idea without particular identification with any one of these definitions.”</p> <blockquote> <p><strong>Church-Turing Thesis</strong>: Every effectively calculable function is a computable function.</p> </blockquote> <p>Church intended for his original thesis to be taken as a definition of what is computable. Likewise, even though he never stated it, Turing had the same intention. In fact, the term “Church’s Thesis” was coined by Kleene many years after Church had published his work. These days, many people take the Church-Turing Thesis as a definition of what is computable; less formally stating that a function is computable if and only if it can be computed by a Turing machine.</p> <p>It’s important to stress that the Church-Turing Thesis is not a definition as many believe. It does not refer to any particular formalization that we’ve discussed and is not a statement that can be formally proven. It is a statement about the nature of computation. Everything that is “effectively calculable”, in the vague and intuitive sense, is a computable function.</p> <div id=refs class="hanging-indent references" role=doc-bibliography> <div id=ref-ackermann1928> <p>Ackermann, Wilhelm. 1928. “Zum Hilbertschen Aufbau Der Reellen Zahlen.” <em>Mathematische Annalen</em> 99.</p> </div> <div id=ref-church1936> <p>Church, Alonzo. 1936. “An Unsolvable Problem of Elementary Number Theory.” <em>American Journal of Mathematics</em> 58.</p> </div> <div id=ref-godel1934> <p>Gödel, Kurt. 1934. <em>On Undecidable Propositions of Formal Mathematics Systems</em>. Institute for Advanced Study.</p> </div> <div id=ref-hilbert1902> <p>Hilbert, David. 1902. “Mathematical Problems.” <em>Bulletin of the American Mathematical Society</em> 8.</p> </div> <div id=ref-kleene1943> <p>Kleene, Stephen Cole. 1943. “Recursive Predicates and Quantifiers.” <em>Transactions of the American Mathematical Society</em> 53.</p> </div> <div id=ref-kleene1952> <p>Kleene, Stephen Cole, NG De Bruijn, J de Groot, and Adriaan Cornelis Zaanen. 1952. <em>Introduction to Metamathematics</em>. Vol. 483. North-Holland Publishing Company.</p> </div> <div id=ref-turing1936> <p>Turing, Alan. 1936. “On Computable Numbers, with an Application to the Entscheidungsproblem.” <em>Proceedings of the London Mathematical Society</em>.</p> </div> <div id=ref-turing1939> <p>Turing, Alan Mathison. 1939. “Systems of Logic Based on Ordinals.” <em>Proceedings of the London Mathematical Society</em> 45.</p> </div> </div> <section id=disqus_thread></section></div></main></div> 